// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package stripe

import (
	"context"
	"reflect"

	"errors"
	"github.com/georgegebbett/pulumi-stripe/sdk/go/stripe/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// With this resource, you can create Product Feature - [Stripe API product feature documentation](https://docs.stripe.com/api/product-feature)
//
// A Product Feature represents an attachment between a feature and a product.
// When a product is purchased that has a feature attached,
// Stripe will create an entitlement to the feature for the purchasing customer.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/georgegebbett/pulumi-stripe/sdk/go/stripe"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			// Product Feature attaches an Entitlement Feature to a Product
//			_, err := stripe.NewProductFeature(ctx, "productFeature", &stripe.ProductFeatureArgs{
//				EntitlementsFeature: pulumi.Any(stripe_entitlements_feature.Feature.Id),
//				Product:             pulumi.Any(stripe_product.Product.Id),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// ```sh
// $ pulumi import stripe:index/productFeature:ProductFeature product_feature <product_feature_id>
// ```
type ProductFeature struct {
	pulumi.CustomResourceState

	// String. The ID of the Entitlements Feature the product will be attached to
	EntitlementsFeature pulumi.StringOutput `pulumi:"entitlementsFeature"`
	// Bool. Has the value `true` if the object exists in live mode or the value `false`
	// if the object exists in test mode.
	Livemode pulumi.BoolOutput `pulumi:"livemode"`
	// String representing the object’s type. Objects of the same type share the same value.
	Object pulumi.StringOutput `pulumi:"object"`
	// String. The ID of the product that this Entitlements Feature will be attached to.
	Product pulumi.StringOutput `pulumi:"product"`
}

// NewProductFeature registers a new resource with the given unique name, arguments, and options.
func NewProductFeature(ctx *pulumi.Context,
	name string, args *ProductFeatureArgs, opts ...pulumi.ResourceOption) (*ProductFeature, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.EntitlementsFeature == nil {
		return nil, errors.New("invalid value for required argument 'EntitlementsFeature'")
	}
	if args.Product == nil {
		return nil, errors.New("invalid value for required argument 'Product'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource ProductFeature
	err := ctx.RegisterResource("stripe:index/productFeature:ProductFeature", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetProductFeature gets an existing ProductFeature resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetProductFeature(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ProductFeatureState, opts ...pulumi.ResourceOption) (*ProductFeature, error) {
	var resource ProductFeature
	err := ctx.ReadResource("stripe:index/productFeature:ProductFeature", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering ProductFeature resources.
type productFeatureState struct {
	// String. The ID of the Entitlements Feature the product will be attached to
	EntitlementsFeature *string `pulumi:"entitlementsFeature"`
	// Bool. Has the value `true` if the object exists in live mode or the value `false`
	// if the object exists in test mode.
	Livemode *bool `pulumi:"livemode"`
	// String representing the object’s type. Objects of the same type share the same value.
	Object *string `pulumi:"object"`
	// String. The ID of the product that this Entitlements Feature will be attached to.
	Product *string `pulumi:"product"`
}

type ProductFeatureState struct {
	// String. The ID of the Entitlements Feature the product will be attached to
	EntitlementsFeature pulumi.StringPtrInput
	// Bool. Has the value `true` if the object exists in live mode or the value `false`
	// if the object exists in test mode.
	Livemode pulumi.BoolPtrInput
	// String representing the object’s type. Objects of the same type share the same value.
	Object pulumi.StringPtrInput
	// String. The ID of the product that this Entitlements Feature will be attached to.
	Product pulumi.StringPtrInput
}

func (ProductFeatureState) ElementType() reflect.Type {
	return reflect.TypeOf((*productFeatureState)(nil)).Elem()
}

type productFeatureArgs struct {
	// String. The ID of the Entitlements Feature the product will be attached to
	EntitlementsFeature string `pulumi:"entitlementsFeature"`
	// String. The ID of the product that this Entitlements Feature will be attached to.
	Product string `pulumi:"product"`
}

// The set of arguments for constructing a ProductFeature resource.
type ProductFeatureArgs struct {
	// String. The ID of the Entitlements Feature the product will be attached to
	EntitlementsFeature pulumi.StringInput
	// String. The ID of the product that this Entitlements Feature will be attached to.
	Product pulumi.StringInput
}

func (ProductFeatureArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*productFeatureArgs)(nil)).Elem()
}

type ProductFeatureInput interface {
	pulumi.Input

	ToProductFeatureOutput() ProductFeatureOutput
	ToProductFeatureOutputWithContext(ctx context.Context) ProductFeatureOutput
}

func (*ProductFeature) ElementType() reflect.Type {
	return reflect.TypeOf((**ProductFeature)(nil)).Elem()
}

func (i *ProductFeature) ToProductFeatureOutput() ProductFeatureOutput {
	return i.ToProductFeatureOutputWithContext(context.Background())
}

func (i *ProductFeature) ToProductFeatureOutputWithContext(ctx context.Context) ProductFeatureOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ProductFeatureOutput)
}

// ProductFeatureArrayInput is an input type that accepts ProductFeatureArray and ProductFeatureArrayOutput values.
// You can construct a concrete instance of `ProductFeatureArrayInput` via:
//
//	ProductFeatureArray{ ProductFeatureArgs{...} }
type ProductFeatureArrayInput interface {
	pulumi.Input

	ToProductFeatureArrayOutput() ProductFeatureArrayOutput
	ToProductFeatureArrayOutputWithContext(context.Context) ProductFeatureArrayOutput
}

type ProductFeatureArray []ProductFeatureInput

func (ProductFeatureArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ProductFeature)(nil)).Elem()
}

func (i ProductFeatureArray) ToProductFeatureArrayOutput() ProductFeatureArrayOutput {
	return i.ToProductFeatureArrayOutputWithContext(context.Background())
}

func (i ProductFeatureArray) ToProductFeatureArrayOutputWithContext(ctx context.Context) ProductFeatureArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ProductFeatureArrayOutput)
}

// ProductFeatureMapInput is an input type that accepts ProductFeatureMap and ProductFeatureMapOutput values.
// You can construct a concrete instance of `ProductFeatureMapInput` via:
//
//	ProductFeatureMap{ "key": ProductFeatureArgs{...} }
type ProductFeatureMapInput interface {
	pulumi.Input

	ToProductFeatureMapOutput() ProductFeatureMapOutput
	ToProductFeatureMapOutputWithContext(context.Context) ProductFeatureMapOutput
}

type ProductFeatureMap map[string]ProductFeatureInput

func (ProductFeatureMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ProductFeature)(nil)).Elem()
}

func (i ProductFeatureMap) ToProductFeatureMapOutput() ProductFeatureMapOutput {
	return i.ToProductFeatureMapOutputWithContext(context.Background())
}

func (i ProductFeatureMap) ToProductFeatureMapOutputWithContext(ctx context.Context) ProductFeatureMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ProductFeatureMapOutput)
}

type ProductFeatureOutput struct{ *pulumi.OutputState }

func (ProductFeatureOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ProductFeature)(nil)).Elem()
}

func (o ProductFeatureOutput) ToProductFeatureOutput() ProductFeatureOutput {
	return o
}

func (o ProductFeatureOutput) ToProductFeatureOutputWithContext(ctx context.Context) ProductFeatureOutput {
	return o
}

// String. The ID of the Entitlements Feature the product will be attached to
func (o ProductFeatureOutput) EntitlementsFeature() pulumi.StringOutput {
	return o.ApplyT(func(v *ProductFeature) pulumi.StringOutput { return v.EntitlementsFeature }).(pulumi.StringOutput)
}

// Bool. Has the value `true` if the object exists in live mode or the value `false`
// if the object exists in test mode.
func (o ProductFeatureOutput) Livemode() pulumi.BoolOutput {
	return o.ApplyT(func(v *ProductFeature) pulumi.BoolOutput { return v.Livemode }).(pulumi.BoolOutput)
}

// String representing the object’s type. Objects of the same type share the same value.
func (o ProductFeatureOutput) Object() pulumi.StringOutput {
	return o.ApplyT(func(v *ProductFeature) pulumi.StringOutput { return v.Object }).(pulumi.StringOutput)
}

// String. The ID of the product that this Entitlements Feature will be attached to.
func (o ProductFeatureOutput) Product() pulumi.StringOutput {
	return o.ApplyT(func(v *ProductFeature) pulumi.StringOutput { return v.Product }).(pulumi.StringOutput)
}

type ProductFeatureArrayOutput struct{ *pulumi.OutputState }

func (ProductFeatureArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ProductFeature)(nil)).Elem()
}

func (o ProductFeatureArrayOutput) ToProductFeatureArrayOutput() ProductFeatureArrayOutput {
	return o
}

func (o ProductFeatureArrayOutput) ToProductFeatureArrayOutputWithContext(ctx context.Context) ProductFeatureArrayOutput {
	return o
}

func (o ProductFeatureArrayOutput) Index(i pulumi.IntInput) ProductFeatureOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *ProductFeature {
		return vs[0].([]*ProductFeature)[vs[1].(int)]
	}).(ProductFeatureOutput)
}

type ProductFeatureMapOutput struct{ *pulumi.OutputState }

func (ProductFeatureMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ProductFeature)(nil)).Elem()
}

func (o ProductFeatureMapOutput) ToProductFeatureMapOutput() ProductFeatureMapOutput {
	return o
}

func (o ProductFeatureMapOutput) ToProductFeatureMapOutputWithContext(ctx context.Context) ProductFeatureMapOutput {
	return o
}

func (o ProductFeatureMapOutput) MapIndex(k pulumi.StringInput) ProductFeatureOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *ProductFeature {
		return vs[0].(map[string]*ProductFeature)[vs[1].(string)]
	}).(ProductFeatureOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ProductFeatureInput)(nil)).Elem(), &ProductFeature{})
	pulumi.RegisterInputType(reflect.TypeOf((*ProductFeatureArrayInput)(nil)).Elem(), ProductFeatureArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ProductFeatureMapInput)(nil)).Elem(), ProductFeatureMap{})
	pulumi.RegisterOutputType(ProductFeatureOutput{})
	pulumi.RegisterOutputType(ProductFeatureArrayOutput{})
	pulumi.RegisterOutputType(ProductFeatureMapOutput{})
}
